# Ultimate Fields Showcase: Colors

This module adds the ability to customize the main color of the theme through a container, which is displayed both on the Theme Options page, as well as a section in the customizer.

## Used features

- The [Options Page](https://www.ultimate-fields.com/docs/locations/options-page/) location, which also displays the container in the Customizer
- The [Message](https://www.ultimate-fields.com/docs/fields/message/), [Select](https://www.ultimate-fields.com/docs/fields/select/)
[Image select](https://www.ultimate-fields.com/docs/fields/image-select/) and [Color](https://www.ultimate-fields.com/docs/fields/color/) fields

## Defining the container, locations and fields

As in every module, we use the `uf.init` action to create additional fields, in this case through the `showcase_colors_fields` function. Unlike most other modules, the body of the function is quite long here, but most of it is quite simple when broken down.

In the beginning of the file, we are defining a variable called `$message`. It contains a message, which will be displayed when viewing the container on the Theme Options page. The message states that the same functionality is available int he configurator with a live preview.

### Creating the container

Next, we are creating the container without adding fields to it:

```php
$container = Container::create( 'theme-colors', __( 'Theme colors', 'showcase' ) )
	->add_location( 'options', $GLOBALS['showcase_options_page'], [
		'show_in_customizer' => true,
		'postmessage_fields' => [ 'color_type', 'main_color', 'predefined_color' ]
	]);
```

During creation, we are assigning the container to a variable, which will be used to add fields to it later. In the arguments of the location we are indicating that we want to `show_in_customizer` with all fields, defined later as postMessage fields.

Please also note that the global variable `showcase_options_page` is being used. The variable is created by the theme and contains a handle to an `UF\Options_Page` object.

### Adding fields

First we are checking if the user is currently viewing a customizer preview with the `is_customize_preview` function. If not, we are adding a Message field that guides the user to the customizer. This is done through the `add_field` method, which accepts a single field.

The main fields of the container are:

1. A Select field named *Color Type*, which lets the user select between the default background, a set of predefined options or a custom color. This field is used to control the visibility of the rest of the fields in the container.
2. An Image Select field named `predefined_color` with a *Color* label. The field allows the user to visually select from a few pre-defined patterns and is only shown when `predefined` is selected in the color type field.
3. A Color field named `main_color`, also labelled *Color*. Since it is only shown when the color type is set to `custom`, there is no issue with using the same label as the previous field.

The logic is based on the color type field as follows:

- When __Default color__ is selected, the default theme color will be used.
- When __Predefined color__ is selected, we will use the key of the selected predefined color.
- When __Custom color__ is selected, users can select a color manually.

## Customizing the CSS in the front-end

In order to customize the colors of the website, we will use some additional CSS. The best way to do so in WordPress is to use the `wp_add_inline_style` function. It works based on a styleseet (the theme stylesheet in this case) and ensures that the initial styles of the website have already been loaded before outputting the custom CSS. This way we do not have to worry about CSS selector complexities.

The custom CSS will be generated by the `showcase_colors_css` function on the `wp_enqueue_scripts` action. In the function, we will check if there is a color selected at all with a `switch` statement, based on the value of the `color_type` field.

We will start by defining `$color = null;`, assuming that no color is selected. Later, in the `switch` statement we will use:

- The value of `predefined_color` when `color_type` is `predefined`
- The value of `main_color` when `color_type` is `custom`

Before generating the actual CSS, the last thing we need to do is to check if a color was loaded at all. If there is one, we will apply the following styles:

- `body` and `.main-background` elements will get a new background color.
- `.main-border` elements get their border color changed.
- `.rte a` will change the text color of standard links to the chosen one.
- The `.menu-triangle` will use the color for its bottom border.

Lastly, we must call the `wp_add_inline_style` function with the new CSS and apply it over the normal stylesheet:

```php
wp_add_inline_style( 'showcase', $css );
```

If we were creating a standard options page, we'd be finished at this point: The fields for selecting a color are in place and we are using their values with PHP.

## Adding dynamic JavaScript to the customizer

However, since we defined that the container should be shown in the Customizer and all of its fields are dynamic, we will need to take care of the dynamic updates in the Customizer preview.

To do that, we will need to enqueue an additional script and provide it with some details. We will use the `customize_preview_init` action in order to only load the script when a user has actually opened the customizer. All of the PHP for this will be contained in the `showcase_colors_js` function.

In there, we will do two things: Enqueue the JavaScript and pass some data to it.

### Enqueueing a special JavaScript file

Enqueueing the `customizer.js` file from the module directory is quite straight-forward: It is enqueued as any other JavaScript file in WordPress. Here it is important to note that `uf-customize-preview` is among the dependencies of the script. Doing this ensures that you can directly use the customizer functionality of Ultimate Fields within the script, specifically the `UF.customize` object.

### Forwarding the existing values to JavaScript

The following code is a part of `showcase_colors_js`:

```php
wp_localize_script( 'showcase-colors', 'showcase_colors', array(
	'color_type'       => get_value( 'color_type', 'option' ),
	'predefined_color' => get_value( 'predefined_color', 'option' ),
	'main_color'       => get_value( 'main_color', 'option' )
));
```

Here we are adding additional data for the `showcase-colors` script. In this case, we are retrieving the data of all 3 fields and providing it to JavaScript. This has to be done, because the Customizer only notifies custom scripts about data changes, but does not preload anything.

Combining the data from the localised script with the changes, sent to the script, provides us with a full definition of the current state.

## Handling changes with JavaScript

All descriptions below are  based on the `customizer.js` file in the module.

### The `updateState` function

This function assumes that the complete state is stored in the `state` variable and has the same logic as the `showcase_colors_css` function in PHP. It will be called every time a value has been changed and will determine which color to be used.

### The `applyColor` function

Once we have determined the color to use, this function will apply it to the same elements, which PHP would apply it to, but the changes will be instant, without any delays.

### Connecting with the Customizer

Once we have all of the functionality to change the color of the website based on the `state` object, we need to actually connect the object with the fields in the Customizer.

```js
$.each( [ 'color_type', 'predefined_color', 'main_color' ], function( i, field ) {
	UF.customize.bind( field, function( value ) {
		state[ field ] = value;
		updateState();
	});
});
```

For this, we are using an `each` loop, which iterates through all fields, which we care about. During each iteration, we are calling the static `UF.customize.bind` method, which accepts the name of a field and a callback, which will be executed any time the value of the field changes.

Within the callback, we are saving the new value in the `state` array and calling `updateState()`. This way the complete chain of functions, described above, is called when the color should be updated.
